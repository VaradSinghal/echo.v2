"use server"

import { createClient } from "@/utils/supabase/server";
import { createServiceRoleClient } from "@/utils/supabase/service";
import { GeminiService } from "@/lib/gemini";
import { GitHubService } from "@/lib/github";

const gemini = new GeminiService();

export async function createPullRequestAction(taskId: string) {
    const supabase = createServiceRoleClient();
    const userClient = createClient();

    // 1. Fetch task and related data
    const { data: task, error: taskError } = await supabase
        .from('agent_tasks')
        .select(`
            *,
            monitored_posts (repo_id)
        `)
        .eq('id', taskId)
        .single();

    if (taskError || !task) return { error: "Task not found" };

    // 2. Fetch User ID (for token)
    const { data: { user } } = await userClient.auth.getUser();
    if (!user) return { error: "Unauthorized" };

    try {
        const github = new GitHubService();
        const repo = task.monitored_posts.repo_id;
        const branch = `echo-agent-fix-${taskId.substring(0, 8)}`;

        // Helper for logging
        const addLog = async (msg: string, status: string = 'processing', step?: string) => {
            const { data: currentTask } = await supabase.from('agent_tasks').select('logs').eq('id', taskId).single();
            const newLogs = [...(currentTask?.logs || []), { timestamp: new Date().toISOString(), message: msg }];
            await supabase.from('agent_tasks').update({
                logs: newLogs,
                status: status,
                current_step: step || msg
            }).eq('id', taskId);
        };

        // 1. Logic for Code Generation
        await addLog("Fetching community sentiment analysis...", "processing", "Synthesizing");

        // Fetch the comment content that triggered this
        const { data: comment } = await supabase
            .from('comments')
            .select('content')
            .eq('id', task.result?.comment_id)
            .single();

        const feedback = comment?.content || "Community request for improvements.";
        const filePath = "README.md"; // Default for demo

        // Fetch current file content (In a real app, this would be a GitHub API call)
        // For the demo, we'll use a standard template if we can't fetch it easily
        const currentCode = "# Echo Project\n\nThis is a placeholder for the repository documentation.";

        await addLog("Generating optimized code patch with Gemini-2.5-flash...");
        const aiResult = await gemini.generateCode(feedback, filePath, currentCode);

        if (!aiResult) {
            await addLog("Code generation failed.", "failed");
            throw new Error("AI Code Generation failed");
        }

        await addLog("Code synthesis complete. Preparing GitHub dispatch...", "processing", "Dispatching");

        // 2. Save Generated Code
        const { data: generatedCode, error: genError } = await supabase
            .from('generated_code')
            .insert({
                task_id: taskId,
                file_path: filePath,
                old_code: currentCode,
                new_code: aiResult.new_code,
                explanation: aiResult.explanation,
                status: 'ready'
            })
            .select()
            .single();

        if (genError) throw new Error(`Failed to save generated code: ${genError.message}`);

        // 3. Create PR via GitHub
        await addLog(`Initializing PR in ${repo} on branch ${branch}...`);
        const pr = await github.createPR(
            user.id,
            repo,
            branch,
            "Agent: " + (aiResult.explanation.substring(0, 50) + "..."),
            `This PR was automatically generated by the Echo Agent based on community feedback.\n\n### Feedback Context\n> ${feedback}\n\n### AI Explanation\n${aiResult.explanation}`,
            [{ path: filePath, content: aiResult.new_code }]
        );

        await addLog(`PR #${pr.number} successfully dispatched to GitHub!`, "completed", "Completed");

        // 4. Update Task & Log PR
        await supabase.from('agent_tasks').update({
            status: 'completed',
            current_step: 'PR Link: ' + pr.html_url
        }).eq('id', taskId);

        await supabase.from('github_prs').insert({
            generated_code_id: generatedCode.id,
            pr_number: pr.number,
            pr_url: pr.html_url,
            status: 'open'
        });

        return { success: true, url: pr.html_url };
    } catch (e: any) {
        console.error("âŒ Agent Action Error:", e.message);
        const { data: currentTask } = await supabase.from('agent_tasks').select('logs').eq('id', taskId).single();
        const failLogs = [...(currentTask?.logs || []), { timestamp: new Date().toISOString(), message: `ERROR: ${e.message}` }];

        await supabase.from('agent_tasks').update({
            status: 'failed',
            logs: failLogs,
            current_step: 'Initialization Failed',
            result: { ...task.result, error: e.message }
        }).eq('id', taskId);
        return { error: e.message };
    }
}

export async function semanticSearch(query: string, repoId: string = "all", threshold: number = 0.7) {
    const supabase = createClient();

    // 1. Generate embedding for the query
    const embedding = await gemini.generateEmbedding(query);
    if (!embedding) return { error: "Failed to generate embedding" };

    // 2. Call RPC to find matches
    const { data, error } = await supabase.rpc('match_comments', {
        query_embedding: embedding,
        match_threshold: threshold,
        match_count: 20
    });

    if (error) return { error: error.message };

    // Filter results if repoId is not "all"
    let results = data || [];
    if (repoId !== "all") {
        results = results.filter((r: any) => r.repo_link === repoId);
    }

    return { data: results };
}

export async function getTopicsForPost(postId: string) {
    const supabase = createClient();

    const { data: comments, error } = await supabase
        .from('comments')
        .select('content')
        .eq('post_id', postId)
        .limit(50);

    if (error || !comments) return { error: "Failed to fetch comments" };

    const topics = await gemini.extractTopics(comments.map(c => c.content));
    return { topics };
}
