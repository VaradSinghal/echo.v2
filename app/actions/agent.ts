"use server"

import { createClient } from "@/utils/supabase/server";
import { GeminiService } from "@/lib/gemini";
import { GitHubService } from "@/lib/github";

const gemini = new GeminiService();

export async function createPullRequestAction(taskId: string) {
    const supabase = createClient();

    // 1. Fetch task and related data
    const { data: task, error: taskError } = await supabase
        .from('agent_tasks')
        .select(`
            *,
            monitored_posts (repo_id)
        `)
        .eq('id', taskId)
        .single();

    if (taskError || !task) return { error: "Task not found" };

    // 2. Fetch User ID (for token)
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { error: "Unauthorized" };

    try {
        const github = new GitHubService();

        // Mocking code generation for the MVP demonstration
        // In a real scenario, we'd fetch the actual file content here
        const repo = task.monitored_posts.repo_id;
        const branch = `echo-agent-fix-${taskId.substring(0, 8)}`;

        const pr = await github.createPR(
            user.id,
            repo,
            branch,
            "Agent: Community Feedback Implementation",
            `This PR was automatically generated by the Echo Agent based on community feedback.\n\n### Feedback Context\n${task.result?.reason || "Consensus from multiple users."}`,
            [{ path: "README.md", content: "# Echo Project\n\nThis file was updated by the agent." }] // Placeholder
        );

        // 3. Log into github_prs
        await supabase.from('github_prs').insert({
            generated_code_id: null, // Would link to actual generated_code entry
            pr_number: pr.number,
            pr_url: pr.html_url,
            status: 'open'
        });

        return { success: true, url: pr.html_url };
    } catch (e: any) {
        return { error: e.message };
    }
}

export async function semanticSearch(query: string, threshold: number = 0.7) {
    const supabase = createClient();

    // 1. Generate embedding for the query
    const embedding = await gemini.generateEmbedding(query);
    if (!embedding) return { error: "Failed to generate embedding" };

    // 2. Call RPC to find matches
    const { data, error } = await supabase.rpc('match_comments', {
        query_embedding: embedding,
        match_threshold: threshold,
        match_count: 20
    });

    if (error) return { error: error.message };
    return { data };
}

export async function getTopicsForPost(postId: string) {
    const supabase = createClient();

    const { data: comments, error } = await supabase
        .from('comments')
        .select('content')
        .eq('post_id', postId)
        .limit(50);

    if (error || !comments) return { error: "Failed to fetch comments" };

    const topics = await gemini.extractTopics(comments.map(c => c.content));
    return { topics };
}
