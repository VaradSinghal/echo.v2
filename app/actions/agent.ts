"use server"

import { createClient } from "@/utils/supabase/server";
import { createServiceRoleClient } from "@/utils/supabase/service";
import { GeminiService } from "@/lib/gemini";
import { GitHubService } from "@/lib/github";
import { headers } from "next/headers";

const gemini = new GeminiService();

export async function createPullRequestAction(taskId: string) {
    const supabase = createServiceRoleClient();
    const userClient = createClient();

    // 1. Fetch task and related data with owner info
    const { data: task, error: taskError } = await supabase
        .from('agent_tasks')
        .select(`
            *,
            monitored_posts (
                repo_id,
                posts (user_id)
            )
        `)
        .eq('id', taskId)
        .single();

    if (taskError || !task) return { error: "Task not found" };

    // 2. Fetch User ID (for token) - try session first, then fallback to post owner
    let targetUserId: string | undefined;
    const { data: { user } } = await userClient.auth.getUser();

    if (user) {
        targetUserId = user.id;
    } else {
        // Fallback to the user who owns the post/repo
        const post = Array.isArray(task.monitored_posts.posts)
            ? task.monitored_posts.posts[0]
            : task.monitored_posts.posts;
        targetUserId = post?.user_id;
    }

    if (!targetUserId) return { error: "Authorized user not found for this task" };

    try {
        const github = new GitHubService();
        const repo = task.monitored_posts.repo_id;
        const branch = `echo-agent-fix-${taskId.substring(0, 8)}`;

        // Helper for logging
        const addLog = async (msg: string, status: string = 'processing', step?: string) => {
            const { data: currentTask } = await supabase.from('agent_tasks').select('logs').eq('id', taskId).single();
            const newLogs = [...(currentTask?.logs || []), { timestamp: new Date().toISOString(), message: msg }];
            await supabase.from('agent_tasks').update({
                logs: newLogs,
                status: status,
                current_step: step || msg
            }).eq('id', taskId);
        };

        // 1. Logic for Code Generation
        await addLog("Fetching community sentiment analysis...", "processing", "Synthesizing");

        // Fetch the comment content that triggered this
        const { data: comment } = await supabase
            .from('comments')
            .select('content')
            .eq('id', task.result?.comment_id)
            .single();

        const feedback = comment?.content || "Community request for improvements.";
        const filePath = "README.md"; // Default for demo

        // Fetch current file content (In a real app, this would be a GitHub API call)
        // For the demo, we'll use a standard template if we can't fetch it easily
        const currentCode = "# Echo Project\n\nThis is a placeholder for the repository documentation.";

        await addLog("Generating optimized code patch with Gemini-2.5-flash...");
        const aiResult = await gemini.generateCode(feedback, filePath, currentCode);

        if (!aiResult) {
            await addLog("Code generation failed.", "failed");
            throw new Error("AI Code Generation failed");
        }

        await addLog("Code synthesis complete. Preparing GitHub dispatch...", "processing", "Dispatching");

        // 2. Save Generated Code
        const { data: generatedCode, error: genError } = await supabase
            .from('generated_code')
            .insert({
                task_id: taskId,
                file_path: filePath,
                old_code: currentCode,
                new_code: aiResult.new_code,
                explanation: aiResult.explanation,
                status: 'ready'
            })
            .select()
            .single();

        if (genError) throw new Error(`Failed to save generated code: ${genError.message}`);

        // 3. Create PR via GitHub
        await addLog(`Initializing PR in ${repo} on branch ${branch}...`);
        const pr = await github.createPR(
            targetUserId,
            repo,
            branch,
            "Agent: " + (aiResult.explanation.substring(0, 50) + "..."),
            `This PR was automatically generated by the Echo Agent based on community feedback.\n\n### Feedback Context\n> ${feedback}\n\n### AI Explanation\n${aiResult.explanation}`,
            [{ path: filePath, content: aiResult.new_code }]
        );

        await addLog(`PR #${pr.number} successfully dispatched to GitHub!`, "completed", "Completed");

        // 4. Update Task & Log PR
        await supabase.from('agent_tasks').update({
            status: 'completed',
            current_step: 'PR Link: ' + pr.html_url
        }).eq('id', taskId);

        await supabase.from('github_prs').insert({
            generated_code_id: generatedCode.id,
            pr_number: pr.number,
            pr_url: pr.html_url,
            status: 'open'
        });

        return { success: true, url: pr.html_url };
    } catch (e: any) {
        console.error("âŒ Agent Action Error:", e.message);
        const { data: currentTask } = await supabase.from('agent_tasks').select('logs').eq('id', taskId).single();
        const failLogs = [...(currentTask?.logs || []), { timestamp: new Date().toISOString(), message: `ERROR: ${e.message}` }];

        await supabase.from('agent_tasks').update({
            status: 'failed',
            logs: failLogs,
            current_step: 'Initialization Failed',
            result: { ...task.result, error: e.message }
        }).eq('id', taskId);
        return { error: e.message };
    }
}

export async function semanticSearch(query: string, repoId: string = "all", threshold: number = 0.7) {
    const supabase = createClient();

    // 1. Generate embedding for the query
    const embedding = await gemini.generateEmbedding(query);
    if (!embedding) return { error: "Failed to generate embedding" };

    // 2. Call RPC to find matches
    const { data, error } = await supabase.rpc('match_comments', {
        query_embedding: embedding,
        match_threshold: threshold,
        match_count: 20
    });

    if (error) return { error: error.message };

    // Filter results if repoId is not "all"
    let results = data || [];
    if (repoId !== "all") {
        results = results.filter((r: any) => r.repo_link === repoId);
    }

    return { data: results };
}

export async function getTopicsForPost(postId: string) {
    const supabase = createClient();

    const { data: comments, error } = await supabase
        .from('comments')
        .select('content')
        .eq('post_id', postId)
        .limit(50);

    if (error || !comments) return { error: "Failed to fetch comments" };

    const topics = await gemini.extractTopics(comments.map(c => c.content));
    return { topics };
}

export async function toggleMonitoringAction(postId: string, repoId: string | null) {
    const supabase = createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { error: "Unauthorized" };

    try {
        const { data: existing } = await supabase
            .from('monitored_posts')
            .select('id, is_active')
            .eq('post_id', postId)
            .maybeSingle();

        if (existing) {
            const { error } = await supabase
                .from('monitored_posts')
                .update({ is_active: !existing.is_active })
                .eq('id', existing.id);
            if (error) throw error;
            return { success: true, active: !existing.is_active };
        } else {
            const { error } = await supabase
                .from('monitored_posts')
                .insert({
                    post_id: postId,
                    repo_id: repoId || 'unknown',
                    is_active: true
                });
            if (error) throw error;
            return { success: true, active: true };
        }
    } catch (e: any) {
        console.error("Error toggling monitoring:", e);
        return { error: e.message };
    }
}

export async function triggerAgentRunAction() {
    try {
        const headersList = headers();
        const host = headersList.get("host");
        const protocol = headersList.get("x-forwarded-proto") || "https";
        const isLocal = host?.includes("localhost") || host?.includes("127.0.0.1");
        const origin = isLocal ? `http://${host}` : `${protocol}://${host}`;

        const resp = await fetch(`${origin}/api/agent/run`, {
            method: 'POST',
            cache: 'no-store'
        });
        return await resp.json();
    } catch (e: any) {
        console.error("Agent trigger error", e);
        return { error: e.message };
    }
}
